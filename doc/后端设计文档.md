## AI 育儿助手 - 后端系统设计方案

**版本:** 0.0.1

**日期:** 2025 年 4 月 27 日

**作者:** Gemini (基于用户反馈调整)

## 1. 引言

#### 1.1. 文档目的

本文档旨在详细阐述“AI 育儿助手”移动端应用后端系统的设计方案，为开发团队提供清晰的技术指引，确保后端系统满足功能性需求（用户管理、多儿童信息管理、包含过敏信息的儿童档案、灵活的日常记录、具备上下文感知和安全检查的 AI 聊天等）和非功能性需求（安全性、可靠性、可扩展性、高性能）。本文档基于 V1.3 版本进行修订，确保所有章节内容完整呈现。

#### 1.2. 项目目标

- **核心价值验证:** 快速构建并验证一个能融合关键安全信息（如过敏信息）、提供灵活记录方式、具备专业感和信任感的 AI 育儿辅助工具的核心价值。
- **后端支撑:** 提供稳定、安全、高效、可扩展的后端服务，支撑移动端（首要）的用户体验。
- **技术基础:** 奠定可持续发展的技术架构，便于未来功能迭代和可能的架构演进。

#### 1.3. 范围

本文档聚焦于后端系统的设计，包括架构风格、技术栈选型、数据模型设计、API 接口定义、核心模块实现细节、跨领域关注点（安全、扩展、可观测性、测试）、用户流程以及相关 AI 库的应用。**不包含部署策略**。

#### 1.4. 目标读者

后端开发工程师、架构师、测试工程师、运维工程师、项目经理、产品经理。

## 2. 用户核心流程图

```mermaid
graph LR
    A[用户打开App] --> B{是否已登录?};
    B -- 是 --> C{选择或添加儿童};
    B -- 否 --> D[进入登录/注册页];
    D --> E{输入手机号/邮箱/密码};
    E --> F[后端验证/注册];
    F -- 成功 --> C;
    F -- 失败 --> D;
    C --> G[主界面];
    G --> H(记录日常);
    G --> I(查看记录);
    G --> J(与AI聊天);
    G --> K(管理儿童信息);
    H --> L{选择记录类型，睡眠/喂养/...};
    L --> M[输入记录详情];
    M --> N[保存记录至后端];
    N --> G;
    I --> O[后端查询记录];
    O --> P[展示记录列表];
    P --> G;
    J --> Q[输入聊天问题];
    Q --> R[发送请求至后端，含问题+儿童ID];
    R --> S(后端: 构建上下文);
    S --> T(后端: 调用LLM);
    T --> U(后端: 安全检查);
    U --> V[返回AI回复给前端];
    V --> W[展示AI回复];
    W --> J;
    K --> X[添加/编辑/删除儿童];
    X --> Y[保存变更至后端];
    Y --> C;
```

**流程说明:**

1. 用户打开应用，判断登录状态。
2. 未登录用户需先完成登录或注册流程。
3. 已登录用户进入主界面前需选择或添加要操作的儿童。
4. 主界面提供核心功能入口：记录日常、查看记录、AI 聊天、管理儿童信息。
5. **记录日常:** 用户选择类型，输入详情，数据保存至后端。
6. **查看记录:** 前端请求，后端查询并返回指定儿童的记录数据。
7. **AI 聊天:** 用户输入问题，前端将问题和当前儿童 ID 发送至后端。后端执行一系列操作（构建上下文、调用大语言模型、进行安全检查）后返回结果给前端展示。
8. **管理儿童信息:** 用户可以添加、编辑或删除儿童档案，变更保存至后端。

## 3. 系统架构

#### 3.1. 架构风格

采用 **模块化单体 (Modular Monolith)** 架构。

- **理由:**
  - **MVP 阶段效率:** 相较于微服务，单体架构在项目初期能显著降低开发、部署和运维的复杂度，加快迭代速度。
  - **逻辑内聚:** 应用的核心功能（用户、儿童、记录、AI 交互）在业务逻辑上紧密相关，初期放在一个服务内更易于管理事务和数据一致性。
  - **模块化设计:** 遵循 NestJS 的模块化特性，强制实施清晰的模块边界（通过 `*.module.ts` 文件组织），每个模块负责特定的业务领域（如 Auth, Children, Records, AI），降低耦合度，提高可维护性。
  - **未来演进:** 清晰的模块化边界为未来在必要时将特定模块（如`ai`, `notifications`, `analytics`）平滑拆分为独立微服务（NestJS 原生支持）奠定了基础。

#### 3.2. 高层架构图 (文字描述)

```
+---------------------+      +------------------------+      +--------------------------+
|   Mobile Client     |----->|   API Gateway (未来)   |----->|  AI Parenting Core       |
| (iOS/Android/Web)   |<-----| (e.g., Nginx, Kong)    |<-----|  Service (NestJS)        |
+---------------------+      +------------------------+      +------------+-------------+
                                                                           |
                                                                           | (TypeORM/Prisma)
                                                                           v
                                                              +------------+-------------+
                                                              |  PostgreSQL DB          |
                                                              | (Users, Children(Allergy),|
                                                              |  Records, ChatHistory,  |
                                                              |  Future: Notifications, |
                                                              |  Content, etc.)         |
                                                              +--------------------------+
                                                                           |
                                                                           | (HTTP/SDK Async via Axios/HttpModule)
                                                                           v
                                                              +------------+-------------+      +---------------------+
                                                              |  AI Service Wrapper     |----->| External LLM API    |
                                                              | (in AI Module: Prompting,|      | (OpenAI, Google AI) |
                                                              |  Context, Safety Checks)|<-----|                     |
                                                              +--------------------------+      +---------------------+
                                                                           |
                                         +---------------------------------+---------------------------------+
                                         | (Async via Task Queue or Direct Async Call)                       |
                                         v                                                                 v
                          +--------------+--------------+      +---------------------+      +--------------+--------------+
                          | Task Queue (BullMQ/NestJS) |----->| Broker (Redis/     |      | Cache (Redis)             |
                          | (Notification, Analytics)|<-----| RabbitMQ)           |      | (Session, Hot Data)       |
                          +----------------------------+      +---------------------+      +----------------------------+
```

## 4. 技术栈选型

|                     |                                     |                                                                                                                                     |
| ------------------- | ----------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------- |
| **组件**            | **技术选型**                        | **理由**                                                                                                                            |
| **编程语言**        | TypeScript (基于 Node.js LTS)       | 提供静态类型检查，提高代码健壮性和可维护性，与 NestJS 深度集成。Node.js 拥有强大的异步 I/O 能力和庞大的 npm 生态。                  |
| **Web 框架**        | NestJS                              | 基于 TypeScript 的渐进式 Node.js 框架，提供强大的模块化、依赖注入、面向切面编程能力，结构清晰，适合构建可维护、可扩展的应用。       |
| **数据库**          | PostgreSQL 14+                      | 功能强大、稳定可靠的关系型数据库，支持 JSONB，事务完善，扩展性良好。                                                                |
| **ORM**             | TypeORM 或 Prisma                   | 流行的 Node.js ORM。TypeORM 装饰器风格与 NestJS 集成良好，功能全面。Prisma 提供更强的类型安全和现代化的开发体验。根据团队偏好选择。 |
| **数据库迁移**      | TypeORM Migrations / Prisma Migrate | ORM 自带或推荐的数据库迁移工具，用于管理数据库结构变更。                                                                            |
| **数据验证/序列化** | class-validator, class-transformer  | NestJS 内置集成，通过装饰器实现 DTO（数据传输对象）的验证和转换，代码简洁，功能强大。                                               |
| **认证机制**        | JWT (JSON Web Tokens)               | 无状态认证机制。使用`@nestjs/jwt`模块简化 JWT 的生成和验证。                                                                        |
| **密码哈希**        | bcrypt 或 argon2 (Node.js 库)       | 业界推荐的强密码哈希算法。使用 Node.js 对应的`bcrypt`或`argon2`库。                                                                 |
| **代码检查/格式化** | ESLint, Prettier, tsc               | 保证代码风格统一，提高代码质量和可维护性。TypeScript 编译器`tsc`进行类型检查。                                                      |

## 5. 数据模型设计 (PostgreSQL)

#### 5.1. 核心实体与关系 (ER 图文字描述)

- 一个 `User` 可以有多个 `Child`。
- 一个 `Child` 可以有多条 `Record` (涵盖睡眠、喂养、排便、笔记等多种类型)。
- `Record` 属于某个 `Child`。
- `ChatHistory` 关联 `User` 和 `Child`。
- (未来) `Notification` 关联 `User` 和 `Child`。
- (未来) `Content` (文章等) 可与 `User` (收藏/推荐) 或 `Child` (年龄段相关) 关联。

#### 5.2. 表结构定义 (SQL DDL)

```
-- 用户表 (Users)
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL, -- MVP阶段可考虑手机号+验证码，此处用email示例
    hashed_password VARCHAR(255) NOT NULL,
    is_active BOOLEAN DEFAULT TRUE NOT NULL,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP NOT NULL,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP NOT NULL
);

-- 儿童信息表 (Children)
CREATE TABLE children (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE, -- 外键关联用户，级联删除
    nickname VARCHAR(100) NOT NULL,
    date_of_birth DATE NOT NULL,
    gender VARCHAR(20) CHECK (gender IN ('Male', 'Female', 'Prefer not to say', 'Other')), -- 性别约束
    allergy_info TEXT, -- 过敏信息，MVP使用TEXT，需在AI交互中重点处理
    more_info TEXT,    -- 更多信息，用于补充背景
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP NOT NULL,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP NOT NULL
);

-- 日常记录表 (Records)
CREATE TABLE records (
    id BIGSERIAL PRIMARY KEY, -- 使用BIGSERIAL应对大量记录
    child_id INTEGER NOT NULL REFERENCES children(id) ON DELETE CASCADE, -- 外键关联儿童，级联删除
    record_type VARCHAR(50) NOT NULL, -- 记录类型，如 'Sleep', 'Feeding', 'Diaper', 'Note', 'Temperature', 'Activity', 'Mood' 等，可动态扩展
    details JSONB, -- 使用JSONB存储不同类型记录的具体细节（喂奶量/类型，睡眠时长/质量，体温值，活动内容，情绪标签等），提供灵活性
    record_timestamp TIMESTAMPTZ NOT NULL, -- 记录发生的时间戳
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP NOT NULL -- 记录创建时间（入库时间）
);
-- 可以在 details 字段上创建 GIN 索引以加速特定键值的查询
-- CREATE INDEX idx_records_details_gin ON records USING GIN (details);

-- 聊天记录表 (ChatHistory)
CREATE TABLE chat_history (
    id BIGSERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id),
    child_id INTEGER REFERENCES children(id), -- 可能与特定儿童相关
    user_message TEXT NOT NULL,
    ai_response TEXT, -- 最终返回给用户的、经过安全处理的响应
    raw_ai_response TEXT, -- 存储未处理的原始AI响应，用于审计和调试
    context_summary TEXT, -- 简要记录本次交互使用的上下文信息（如涉及的记录类型和时间范围）
    safety_flags VARCHAR(255), -- 记录触发的安全规则 (如 'allergy_detected', 'medical_advice_warning')
    feedback SMALLINT CHECK (feedback IN (1, -1)), -- 用户反馈：1=有用，-1=没用
    request_timestamp TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP NOT NULL,
    response_timestamp TIMESTAMPTZ
);

-- (未来) 提醒表 (Notifications)
-- CREATE TABLE notifications ( ... );

-- (未来) 内容表 (Content)
-- CREATE TABLE content ( ... );
```

#### 5.3. 索引策略

- **主键:** 自动创建索引。
- **外键:** `children.user_id`, `records.child_id`, `chat_history.user_id`, `chat_history.child_id` 应创建索引，加速关联查询。
- **常用查询字段:**
  - `users.email` (自带 UNIQUE 索引)。
  - `records.record_timestamp` (按时间范围查询记录非常频繁，必须加索引)。
  - `records.child_id` 与 `records.record_timestamp` 的复合索引可能对查询特定孩子的近期记录更有效。
  - `records.record_type` (如果按类型查询频繁)。
  - `records.details` (GIN 索引，如果需要基于 JSONB 内部字段查询)。
  - `chat_history.child_id` 和 `chat_history.request_timestamp` 的复合索引。

#### 5.4. 敏感信息处理

- `allergy_info`, `more_info`, `records.details` (某些类型), `chat_history` 可能包含敏感信息 (PII/PHI)。
- **MVP 策略:** 使用 TEXT/JSONB 存储，依赖应用层安全控制和数据库访问控制。AI 交互中对 `allergy_info` 做特殊处理。
- **未来增强:** 考虑数据库层加密 (`pgcrypto`)、严格审计、数据脱敏、过敏信息规范化等。

## 6. API 设计 (RESTful)

#### 6.1. 设计原则

- **资源导向:** 使用名词表示资源路径 (e.g., `/children`, `/records`)。
- **HTTP 动词:** 使用标准 HTTP 方法表达操作 (GET, POST, PUT, PATCH, DELETE)。
- **状态码:** 使用标准 HTTP 状态码指示结果 (2xx 成功, 4xx 客户端错误, 5xx 服务器错误)。
- **无状态:** 每个请求应包含所有必要信息，服务器不依赖先前请求的状态（JWT 实现）。
- **版本控制:** 在 URL 中包含版本号 (`/api/v1/...`)，便于未来 API 升级。
- **统一响应格式:** 成功和错误响应使用一致的 JSON 结构。

#### 6.2. 统一响应结构示例

```
// 成功响应 (Success Response)
{
  "success": true,
  "data": { ... } // or [ ... ] or null
}

// 错误响应 (Error Response)
{
  "success": false,
  "error": {
    "code": "INTERNAL_ERROR_CODE", // 内部错误码
    "message": "User-friendly error message.", // 用户友好的错误信息
    "details": { ... } // (可选) 额外的错误细节
  }
}
```

#### 6.3. 主要 API 端点

- **认证 (Auth)**
  - `POST /api/v1/auth/register`: 用户注册 (email, password) -> `201 Created`, `{ "success": true, "data": null }`
  - `POST /api/v1/auth/login`: 用户登录 (email, password) -> `200 OK`, `{ "success": true, "data": { "access_token": "...", "refresh_token": "...", "token_type": "bearer" } }`
  - `POST /api/v1/auth/refresh`: 刷新 Access Token (refresh_token) -> `200 OK`, `{ "success": true, "data": { "access_token": "...", "token_type": "bearer" } }`
  - `GET /api/v1/auth/me`: 获取当前用户信息 (需要认证) -> `200 OK`, `{ "success": true, "data": { "id": ..., "email": "...", "is_active": ... } }`
- **儿童信息 (Children)** (均需要认证)
  - `POST /api/v1/children`: 添加新儿童信息 -> `201 Created`, `{ "success": true, "data": { child object } }`
  - `GET /api/v1/children`: 获取当前用户的所有儿童列表 -> `200 OK`, `{ "success": true, "data": [ { child object }, ... ] }`
  - `GET /api/v1/children/{child_id}`: 获取指定儿童信息 -> `200 OK`, `{ "success": true, "data": { child object } }`
  - `PUT /api/v1/children/{child_id}`: 完整更新指定儿童信息 -> `200 OK`, `{ "success": true, "data": { child object } }`
  - `PATCH /api/v1/children/{child_id}`: 部分更新指定儿童信息 -> `200 OK`, `{ "success": true, "data": { child object } }`
  - `DELETE /api/v1/children/{child_id}`: 删除指定儿童信息 -> `204 No Content`
- **日常记录 (Records)** (均需要认证)
  - `POST /api/v1/children/{child_id}/records`: 添加记录 (请求体包含 `record_type`, `record_timestamp`, `details` (JSONB)) -> `201 Created`, 返回 record object。
  - `GET /api/v1/children/{child_id}/records`: 获取记录列表 (支持分页 `page`, `size`；支持按 `record_timestamp` 范围 `start_ts`, `end_ts` 过滤；支持按 `record_type` 过滤) -> `200 OK`, 返回分页结构数据。
  - `DELETE /api/v1/records/{record_id}`: 删除单条记录 (需校验权限) -> `204 No Content`。
- **AI 聊天 (Chat)** (需要认证)
  - `POST /api/v1/chat`: 发送聊天消息 (请求体包含 `message: str`, `child_id: int`) -> `200 OK`, 返回 `{ "success": true, "data": { "reply": "...", "chat_id": "...", "disclaimer": "..." } }`。返回 `chat_id` 用于后续反馈。
  - `GET /api/v1/children/{child_id}/chats`: 分页获取指定宝宝的历史聊天记录 (需要认证，支持 `page`, `size`) -> `200 OK`, 返回分页数据。
  - `POST /api/v1/chats/{chat_id}/feedback`: 对某条 AI 回复提交反馈 (请求体包含 `feedback: int` (1 或 -1)) -> `200 OK`。

#### 6.4. 数据验证

- 所有 API 请求的输入都将使用 NestJS 的管道(Pipes)和`class-validator`装饰器对 DTO 进行严格验证（类型、格式、必需字段、值范围等）。验证失败将由框架自动返回`400 Bad Request`。

## 7. 核心模块深入设计

#### 7.1. 认证与授权 (Auth Module - 基于 NestJS)

- **流程:**
  1. 注册：接收 DTO，验证数据（如 email 格式唯一性），使用`bcrypt`或`argon2`对密码加盐哈希后通过 AuthService 存入数据库。
  2. 登录：接收 DTO，AuthService 查询用户，验证密码，成功则使用`@nestjs/jwt`的`JwtService`生成 Access Token（短时效，如 15-60 分钟）和 Refresh Token（长时效，如 7-30 天，安全存储）。
  3. API 访问：客户端在请求头 `Authorization: Bearer <access_token>` 中携带 Access Token。使用 NestJS 的守卫(Guard)和`@nestjs/passport` (配置 JwtStrategy) 验证 Token 有效性（签名、时效）。
  4. Token 刷新：实现刷新接口，验证 Refresh Token 有效性，颁发新的 Access Token。实施 Refresh Token 吊销机制（如使用 Redis 存储已吊销的 Token ID 列表）。
- **JWT Payload:** 包含 `sub` (用户 ID), `exp` (过期时间), `iat` (签发时间), `iss` (签发者), `aud` (接收者) 等标准字段。不应包含敏感信息。
- **密钥管理:** JWT 签名密钥必须保密，通过 NestJS 配置模块 (`@nestjs/config`) 从环境变量或 Secrets Manager 安全加载，定期轮换。
- **权限:** 使用 NestJS 守卫(Guard)实现。在守卫中获取请求用户对象(通过 JWT 验证获得)，并结合请求参数（如`child_id`）进行权限校验（例如，查询数据库确认该`child_id`属于当前`user_id`）。

#### 7.2. 儿童与记录管理 (Children & Records Modules - 基于 NestJS)

- **数据一致性:** 利用数据库事务。TypeORM/Prisma 都支持事务操作。数据库外键约束（如`ON DELETE CASCADE`）保证基础的数据引用完整性。
- **记录灵活性:** RecordsService 处理传入的包含`details` (JSONB) 的 DTO。使用`class-transformer`和`class-validator`，可以为不同的`record_type`定义不同的 DTO 类或使用条件验证，确保`details`字段内容的有效性。
- **查询优化:** Service 层使用 ORM（TypeORM/Prisma）提供的 API 实现高效的分页逻辑（如`take`/`skip`或基于游标）、过滤（`where`子句）和排序（`orderBy`）。确保 ORM 生成的 SQL 能有效利用数据库索引。

#### 7.3. AI 集成 (AI Module - 基于 NestJS)

- **核心原则:** 安全第一，情境感知，用户赋能，明确局限。
- **`AIService` 抽象层:**
  - 定义清晰的接口 (`interface AIService { getChatResponse(prompt: string, config: AIConfig): Promise<string>; }`)。
  - 实现具体的服务类 (`OpenAIService`, `GoogleAIService`等)，使用 NestJS 的`HttpModule`或`axios`库封装与特定外部 LLM API 的异步交互逻辑（处理 HTTP 请求、认证、错误）。
  - 通过 NestJS 的依赖注入机制提供配置好的 AI 服务实例。
- **`ContextBuilder` 服务:**
  - 注入相关的 Service（如 `RecordsService`, `ChildrenService`）。
  - 异步调用这些 Service 的方法，根据传入的`child_id`获取儿童基本信息（年龄、性别、**过敏信息**、更多信息）和近期相关记录（可配置时间窗口）。
  - 对获取的记录（尤其是 JSONB `details`）进行结构化总结，提取关键信息（如：“过去 24 小时睡眠总时长 X 小时，Y 次小睡”，“最近一次喂奶时间 Z，类型 A，量 B”）。**特别注意：过敏信息必须包含在上下文中，并进行明确标识，以便后续处理和 LLM 参考。**
  - 格式化所有信息为文本块，注意控制总长度以符合 LLM 的 Token 限制。
- **`PromptEngine` 服务/逻辑:**
  - **System Prompt:** 精心设计，包含角色定义（如“你是一个专业、有爱心且谨慎的 AI 育儿助手”）、目标（“基于提供的上下文信息回答用户问题”）、行为准则、**严格的安全指令（强调绝不能给出医疗建议，遇到紧急情况提示用户就医，必须规避提及已知的过敏原）**，并可能要求 AI 在回复中说明其信息来源（如“根据您记录的睡眠情况...”）。
  - **动态 Prompt 组装:** 将 System Prompt、`ContextBuilder`生成的上下文信息、以及用户的原始问题组合成最终发送给 LLM 的完整 Prompt。
- **`SafetyChecker` 服务 (强制安全层):**
  - 注入 `ChildrenService` 以获取指定儿童的`allergy_info`。
  - **过敏检查:**
    - 接收 LLM 的原始回复文本和从数据库获取的儿童`allergy_info`。
    - **预处理:** 将`allergy_info`（可能为逗号分隔的文本）解析为结构化的过敏原列表（如 `['牛奶', '花生', '鸡蛋']`），进行小写、去空格等标准化处理。
    - **检查:** 在 LLM 原始回复文本（同样进行标准化处理）中，使用全词匹配（如正则表达式 `\b(牛奶|花生|鸡蛋)\b`）严格查找是否存在过敏原列表中的任何一项。
    - **处理策略:** **一旦检测到任何已知的过敏原，立即丢弃 LLM 的回复，并返回一个预定义的、绝对安全的通用提示** （例如：“检测到可能涉及宝宝的过敏原，为安全起见，无法提供相关建议。请务必咨询医生或专业人士。”）。**绝不尝试修改或过滤 AI 回复中的过敏内容。**
    - 在`ChatHistory`中记录 `safety_flags` 为 `allergy_detected`。
  - **医疗建议检查 (可选增强):** 使用关键词列表（如“诊断”，“治疗”，“处方”，“药”，”建议剂量“等）或更复杂的规则/模型判断 AI 回复是否可能构成医疗建议。若判断为是，可选择性地强化免责声明或返回更通用的安全提示，并记录 `safety_flags`。
  - **强制免责声明:** 无论安全检查结果如何（即使是返回了安全提示），**必须**在最终返回给用户的 `ai_response` 文本末尾附加标准的、硬编码的免责声明文本（例如：“本回复仅供参考，不能替代专业医疗建议、诊断或治疗。如有健康问题，请及时就医。”）。
- **异步处理:** AI 聊天接口的 Controller 方法必须使用`async/await`，确保整个调用链（数据库查询、上下文构建、AI 服务调用、安全检查）是异步非阻塞的，不会长时间占用 Node.js 事件循环。
- **日志记录:** 使用 NestJS 内置的`Logger`或集成`winston`/`pino`等库，详细记录每次 AI 交互的关键信息：用户 ID、儿童 ID、完整的 Prompt（可能需要脱敏处理敏感信息）、LLM 原始响应、构建的上下文摘要、安全检查结果及触发的标志、最终返回给用户的响应、请求和响应时间戳。这些日志对于调试、审计以及未来的模型/Prompt 优化至关重要。存储在`ChatHistory`表或专门的日志系统中。
- **错误处理:** 使用 NestJS 的异常过滤器(Exception Filters)统一处理 AI 服务调用过程中可能出现的各种错误（如网络超时、API 密钥错误、速率限制、无效请求等），向客户端返回标准化的、用户友好的错误响应（如 503 Service Unavailable，并附带错误代码和消息）。考虑在调用外部 API 时实现适当的重试逻辑（例如使用`axios-retry`库，并采用指数退避策略）。

## 8. LangChain.js 在本项目的应用方案

基于项目需求，我们选择 **LangChain.js** 作为本项目推荐的 LLM 应用框架，以利用其强大的编排能力和灵活性。以下方案将替换或增强第 7.3 节中部分手动实现的逻辑。

**8.1 基础设置与模块集成**

- **安装依赖:** `npm install langchain @langchain/openai @langchain/community` (以及可能需要的其他模型或集成库，如 `@langchain/google-genai`)
- **创建 `LangChainModule`:**
  - 在 NestJS 项目中创建 `LangChainModule` (`langchain.module.ts`)。
  - 配置并提供 `LANGCHAIN_CHAT_MODEL` (如 `ChatOpenAI` 或 `ChatGoogleGenerativeAI`)。
  - 确保 `ConfigModule` 已导入，并能读取 API 密钥。
  - 将此模块导入 `AppModule`。
  ```
  // langchain.module.ts
  import { Module, Global } from '@nestjs/common';
  import { ConfigModule, ConfigService } from '@nestjs/config';
  import { ChatOpenAI } from '@langchain/openai';
  // import { ChatGoogleGenerativeAI } from "@langchain/google-genai";

  export const LANGCHAIN_CHAT_MODEL = 'LANGCHAIN_CHAT_MODEL';

  @Global() // 可选，如果希望在全局注入
  @Module({
    imports: [ConfigModule], // 确保ConfigModule已导入
    providers: [
      {
        provide: LANGCHAIN_CHAT_MODEL,
        useFactory: (configService: ConfigService) => {
          // 可以根据配置选择不同的模型
          return new ChatOpenAI({
            apiKey: configService.get<string>('OPENAI_API_KEY'),
            modelName: 'gpt-4o', // 或其他模型
            temperature: 0.7, // 配置模型参数
          });
          /*
          // Example for Google Gemini
          return new ChatGoogleGenerativeAI({
            apiKey: configService.get<string>('GOOGLE_API_KEY'),
            modelName: "gemini-pro",
            temperature: 0.7,
          });
          */
        },
        inject: [ConfigService],
      },
      // 可以提供其他LangChain相关服务，如向量存储等
    ],
    exports: [LANGCHAIN_CHAT_MODEL],
  })
  export class LangChainModule {}
  ```

**8.2 重构 `AI Module` (核心应用)**

- **`AIService` (或 `LangChainService`):**
  - 注入 `LANGCHAIN_CHAT_MODEL` (`@Inject(LANGCHAIN_CHAT_MODEL) private chatModel: BaseChatModel`)。
  - 注入 `ChildrenService`, `RecordsService`, `ChatHistoryRepository` (或对应的 Service)。
  - **核心方法:** `getAiReply(userId: number, childId: number, userMessage: string): Promise<{ reply: string; chatId: string; disclaimer: string; /* 可选字段 */ }>`
  - 此方法内部将构建并调用核心的 LangChain 链 (使用 LCEL - LangChain Expression Language)。
- **核心链 (Core Parenting Chain) 构建 (使用 LCEL)**
  ```ts
  // aiservice.ts (或 langchain.service.ts)
  import { Injectable, Inject, NotFoundException } from '@nestjs/common'; // 引入 NotFoundException
  import { ConfigService } from '@nestjs/config';
  import { BaseChatModel } from '@langchain/core/language_models/chat_models';
  import {
    ChatPromptTemplate,
    SystemMessagePromptTemplate,
    HumanMessagePromptTemplate,
  } from '@langchain/core/prompts';
  import {
    RunnableSequence,
    RunnableLambda,
    RunnablePassthrough,
    RunnableMap,
  } from '@langchain/core/runnables';
  import { StringOutputParser } from '@langchain/core/output_parsers';
  import { LANGCHAIN_CHAT_MODEL } from './langchain.module';
  import { ChildrenService } from '../children/children.service';
  import { RecordsService } from '../records/records.service';
  import { ChatHistoryRepository } from './chat-history.repository'; // 假设使用 Repository
  import { calculateAge, formatRecord } from './utils'; // 假设辅助函数在此
  import { RecordEntity } from '../records/entities/record.entity'; // 假设实体路径
  import { ChildEntity } from '../children/entities/child.entity'; // 假设实体路径
  import { ChatHistoryEntity } from './entities/chat-history.entity'; // 假设实体路径

  @Injectable()
  export class AIService {
    private parentingChain: RunnableSequence;

    constructor(
      @Inject(LANGCHAIN_CHAT_MODEL) private chatModel: BaseChatModel,
      private readonly childrenService: ChildrenService,
      private readonly recordsService: RecordsService,
      private readonly chatHistoryRepository: ChatHistoryRepository,
      private readonly configService: ConfigService,
    ) {
      this.parentingChain = this.buildParentingChain(); // 在构造函数中构建链
    }

    // --- 1. 构建上下文的 Runnable ---
    private buildContextRunnable(): RunnableLambda<
      { childId: number; userId: number },
      { contextText: string; allergyInfo: string }
    > {
      return new RunnableLambda({
        func: async (input: { childId: number; userId: number }) => {
          // 注意：userId 需要从认证流程中获取并传入
          const child: ChildEntity | null =
            await this.childrenService.findOneForUser(
              input.childId,
              input.userId,
            ); // 确保有权限检查
          if (!child) {
            // 使用 NestJS 的异常，如果需要可以自定义 Exception Filter 处理
            throw new NotFoundException(
              `Child with ID ${input.childId} not found or access denied for user ${input.userId}.`,
            );
          }
          const recentRecords: RecordEntity[] =
            await this.recordsService.findRecentForChild(input.childId, 48); // 获取近48小时记录

          let context = `儿童信息:\n`;
          context += `- 昵称: ${child.nickname}\n`;
          context += `- 年龄: ${calculateAge(child.date_of_birth)}\n`;
          context += `- 性别: ${child.gender}\n`;
          if (child.allergy_info) {
            context += `- **重要：已知过敏:** ${child.allergy_info}\n`;
          }
          if (child.more_info) {
            context += `- 补充信息: ${child.more_info}\n`;
          }

          context += `\n近期记录 (过去48小时):\n`;
          if (recentRecords.length > 0) {
            // 限制记录数量防止上下文过长
            context += recentRecords
              .map((r) => `- ${formatRecord(r)}`)
              .slice(0, 20)
              .join('\n');
          } else {
            context += `- 暂无记录\n`;
          }

          return {
            contextText: context,
            allergyInfo: child.allergy_info || '',
          };
        },
      });
    }

    // --- 2. 构建 Prompt 模板 ---
    private buildChatPromptTemplate(): ChatPromptTemplate {
      const systemPrompt = `你是一个专业、有爱心且谨慎的AI育儿助手。
      你的任务是基于以下提供的上下文信息来回答用户关于育儿的问题。
      上下文信息包括儿童的基本情况和近期的日常记录。
      必须严格遵守以下安全准则:
      1. **绝不能提供任何形式的医疗建议、诊断或治疗方案。** 如果用户问题涉及健康状况，应提示用户咨询专业医生。
      2. **必须严格规避提及儿童已知过敏原相关的食物或物品。** 上下文中会明确标识已知过敏信息。
      3. 如果遇到紧急情况的描述，应立即提示用户寻求紧急医疗帮助。
      4. 回答应清晰、友好、易于理解，并尽可能结合上下文信息进行个性化回复。
      5. 如果上下文中没有足够信息回答问题，请坦诚告知。
      
      ## 上下文信息: {context}
      `;

      const humanPrompt = '{userMessage}';
      return ChatPromptTemplate.fromMessages([
        SystemMessagePromptTemplate.fromTemplate(systemPrompt),
        HumanMessagePromptTemplate.fromTemplate(humanPrompt),
      ]);
    }

    // --- 3. 构建安全检查与格式化的 Runnable ---
    private buildSafetyCheckRunnable(): RunnableLambda<
      { llmResponse: string; allergyInfo: string },
      {
        reply: string;
        disclaimer: string;
        safetyFlags: string | null;
        rawResponse: string;
      }
    > {
      return new RunnableLambda({
        func: async (input: { llmResponse: string; allergyInfo: string }) => {
          const { llmResponse, allergyInfo } = input;
          let finalReply = llmResponse;
          let safetyFlagsList: string[] = [];

          // 过敏检查
          if (allergyInfo) {
            const allergens = allergyInfo
              .toLowerCase()
              .split(/[,，、\s]+/)
              .filter(Boolean);
            const responseLower = llmResponse.toLowerCase();
            const detectedAllergen = allergens.find(
              (allergen) =>
                new RegExp(`\\b${allergen}\\b`, 'i').test(responseLower), // 使用 'i' 进行不区分大小写匹配
            );
            if (detectedAllergen) {
              finalReply =
                '检测到可能涉及宝宝的过敏原，为安全起见，无法提供相关建议。请务必咨询医生或专业人士。';
              safetyFlagsList.push('allergy_detected');
            }
          }

          // 医疗建议检查 (仅在未触发过敏时检查)
          if (!safetyFlagsList.includes('allergy_detected')) {
            const medicalKeywords = [
              '诊断',
              '治疗',
              '处方',
              '药',
              '剂量',
              '病症',
            ]; // 示例关键词，需要完善
            if (medicalKeywords.some((kw) => llmResponse.includes(kw))) {
              safetyFlagsList.push('medical_advice_warning');
              // 可以选择不修改回复，仅添加标记，让免责声明更突出
              // 例如: finalReply = `请注意，以下内容不构成医疗建议：\n${llmResponse}`;
            }
          }

          // 强制添加免责声明
          const disclaimer =
            '本回复仅供参考，不能替代专业医疗建议、诊断或治疗。如有健康问题，请及时就医。';
          // 避免在安全提示后重复添加免责声明
          if (!safetyFlagsList.includes('allergy_detected')) {
            finalReply += `\n\n${disclaimer}`;
          }

          return {
            reply: finalReply,
            disclaimer: disclaimer, // 始终返回标准免责声明文本
            safetyFlags:
              safetyFlagsList.length > 0 ? safetyFlagsList.join(';') : null,
            rawResponse: llmResponse, // 保留原始回复用于记录
          };
        },
      });
    }

    // --- 4. 构建完整的链 ---
    private buildParentingChain(): RunnableSequence {
      const contextRunnable = this.buildContextRunnable();
      const chatPromptTemplate = this.buildChatPromptTemplate();
      const safetyCheckRunnable = this.buildSafetyCheckRunnable();

      // 使用 RunnableMap 来并行处理和传递数据
      const chain = RunnableSequence.from([
        // 输入: { childId: number, userMessage: string, userId: number }
        RunnableMap.from({
          // 获取上下文和过敏信息，同时传递 userId
          contextData: (input) =>
            contextRunnable.invoke({
              childId: input.childId,
              userId: input.userId,
            }),
          // 直接传递用户消息
          userMessage: new RunnablePassthrough().pipe(
            (input) => input.userMessage,
          ),
        }),
        // 输出: { contextData: { contextText: string, allergyInfo: string }, userMessage: string }
        RunnableMap.from({
          // 准备给 Prompt 的输入
          promptArgs: (input) => ({
            context: input.contextData.contextText,
            userMessage: input.userMessage,
          }),
          // 向下传递过敏信息给安全检查步骤
          allergyInfo: (input) => input.contextData.allergyInfo,
          // 传递上下文文本用于可能的记录
          contextText: (input) => input.contextData.contextText,
        }),
        // 输出: { promptArgs: { context: string, userMessage: string }, allergyInfo: string, contextText: string }
        RunnableMap.from({
          // 调用 LLM
          llmResponse: (input) =>
            chatPromptTemplate
              .pipe(this.chatModel)
              .pipe(new StringOutputParser())
              .invoke(input.promptArgs),
          // 继续传递过敏信息和上下文文本
          allergyInfo: (input) => input.allergyInfo,
          contextText: (input) => input.contextText, // 传递上下文文本
        }),
        // 输出: { llmResponse: string, allergyInfo: string, contextText: string }
        // 执行安全检查和最终格式化
        (input) =>
          safetyCheckRunnable.invoke({
            llmResponse: input.llmResponse,
            allergyInfo: input.allergyInfo,
          }),
        // 最终输出: { reply: string, disclaimer: string, safetyFlags: string | null, rawResponse: string }
        // 注意：contextText 在这里丢失了，如果需要记录，需要在上一步或下一步处理
      ]);

      // 如果需要记录 contextSummary，可以调整链结构，例如在安全检查后加一步
      const chainWithContextLogging = RunnableSequence.from([
        // ... 上面的链直到 RunnableMap.from 调用 LLM ...
        RunnableMap.from({
          // 调用 LLM
          llmResponse: (input) =>
            chatPromptTemplate
              .pipe(this.chatModel)
              .pipe(new StringOutputParser())
              .invoke(input.promptArgs),
          // 继续传递过敏信息和上下文文本
          allergyInfo: (input) => input.allergyInfo,
          contextText: (input) => input.contextText, // 传递上下文文本
        }),
        // 输出: { llmResponse: string, allergyInfo: string, contextText: string }
        RunnableMap.from({
          // 执行安全检查
          safetyResult: (input) =>
            safetyCheckRunnable.invoke({
              llmResponse: input.llmResponse,
              allergyInfo: input.allergyInfo,
            }),
          // 传递上下文文本
          contextText: (input) => input.contextText,
        }),
        // 输出: { safetyResult: { reply: string, ... }, contextText: string }
        // 添加一步来合并结果并包含 contextSummary
        (input) => ({
          ...input.safetyResult,
          contextSummary: input.contextText.substring(0, 500), // 截取部分上下文作为摘要
        }),
        // 最终输出: { reply: string, disclaimer: string, safetyFlags: string | null, rawResponse: string, contextSummary: string }
      ]);

      return chainWithContextLogging; // 返回包含上下文记录的链
    }

    // --- 5. 核心调用方法 ---
    async getAiReply(
      userId: number,
      childId: number,
      userMessage: string,
    ): Promise<{ reply: string; chatId: string; disclaimer: string }> {
      const requestTimestamp = new Date(); // 记录请求时间

      // 调用预先构建好的链，传入 userId
      const result = await this.parentingChain.invoke({
        childId,
        userMessage,
        userId,
      });

      // --- 保存聊天记录 ---
      const chatEntry = new ChatHistoryEntity(); // 创建实体实例
      chatEntry.userId = userId;
      chatEntry.childId = childId;
      chatEntry.userMessage = userMessage;
      chatEntry.aiResponse = result.reply;
      chatEntry.rawAiResponse = result.rawResponse;
      chatEntry.contextSummary = result.contextSummary; // 保存上下文摘要
      chatEntry.safetyFlags = result.safetyFlags;
      chatEntry.requestTimestamp = requestTimestamp;
      chatEntry.responseTimestamp = new Date();

      const savedEntry = await this.chatHistoryRepository.save(chatEntry);
      // --- 保存结束 ---

      return {
        reply: result.reply,
        chatId: savedEntry.id.toString(), // 返回数据库记录ID
        disclaimer: result.disclaimer,
      };
    }
  }
  ```
- **实现辅助函数:**
  - `calculateAge(dateOfBirth: Date): string`: 计算并格式化儿童年龄。
  - `formatRecord(record: RecordEntity): string`: 将单条记录格式化为文本。
- **集成与测试:**
  - 在 `AIChatController` 中注入 `AIService`。
  - `POST /api/v1/chat` 路由调用 `AIService.getAiReply`。
  - 编写单元测试（Mock LangChain 链或其组件）和集成测试（可能需要 Mock LLM 调用）。

**优势:**

- **结构化与可读性:** 使用 LCEL 将复杂流程分解为可组合的步骤，代码更清晰。
- **可维护性:** 修改 Prompt、更换模型、调整安全逻辑更方便，只需修改对应的 Runnable。
- **可扩展性:** 易于插入新的处理步骤（如对话记忆、RAG 检索）。
- **标准化:** 利用 LangChain 提供的标准接口和组件。

**注意:**

- 上述代码为示例，需要根据实际项目结构和依赖进行调整（如 Service 方法签名、实体定义、Repository 注入）。
- 错误处理（如 LLM 调用失败、数据库查询失败、权限不足）需要在链的适当位置或使用 `.withRetry()`、NestJS 的异常处理机制等添加。
- 上下文的构建和格式化（尤其是记录数量限制和格式化方式）仍需仔细设计以优化效果和控制成本。
- 安全检查是核心，必须严格测试（包括各种边界情况和过敏原的变体）。

通过采用 LangChain.js，本项目可以在保证 MVP 功能实现的同时，为未来更复杂的 AI 能力打下坚实的基础，并提高开发效率和代码的可维护性。

## 9. 跨领域关注点 (Cross-Cutting Concerns)

#### 9.1. 安全性 (Security)

- **输入验证:** 使用 NestJS 管道(Pipes)和`class-validator`装饰器验证所有 API 输入（DTOs），防止注入、类型错误等。对文本输入进行必要的清理（如去除潜在的脚本标签，虽然框架通常会处理）。
- **输出编码:** 确保 API 响应中的数据被正确编码，防止 XSS 攻击。现代框架如 NestJS 通常默认处理。
- **认证/授权:** 严格执行 JWT 认证。使用 NestJS 守卫(Guard)确保用户只能访问其自身的数据（基于 Token 中的用户 ID 进行数据过滤和权限检查）。
- **依赖安全:** 定期使用`npm audit`或`yarn audit`扫描第三方库漏洞，或集成 Snyk 等自动化工具，并及时更新存在漏洞的依赖。
- **速率限制:** 对关键 API 端点（特别是登录、注册、AI 聊天接口）实施速率限制，防止暴力破解和 API 滥用。使用`@nestjs/throttler`模块。
- **密码安全:** 使用`bcrypt`或`argon2`库对用户密码进行加盐强哈希存储，绝不存储明文密码。
- **敏感数据:** 最小化敏感数据（PII/PHI）的存储和传输。如果存储，考虑在应用层或数据库层（如使用`pgcrypto`）进行加密。严格控制对敏感数据的访问权限。遵守相关隐私法规（如 GDPR, CCPA, PIPL）。
- **CORS (跨域资源共享):** 在 NestJS 中配置合适的 CORS 策略，仅允许受信任的前端源（或其他服务）访问 API。
- **安全头:** 使用`helmet`中间件（可轻松集成到 NestJS）设置必要的 HTTP 安全头 (如 `Strict-Transport-Security`, `Content-Security-Policy`, `X-Content-Type-Options`, `X-Frame-Options`)，增强 Web 应用的安全性。
- **密钥管理:** 使用`@nestjs/config`模块安全地加载和管理 API 密钥、数据库密码、JWT 签名密钥等敏感配置。优先从环境变量或专门的 Secrets Management 服务（如 AWS Secrets Manager, Google Secret Manager, HashiCorp Vault）读取，避免硬编码。

#### 9.2. 可扩展性 (Scalability)

- **无状态服务:** 将 NestJS 应用设计为无状态，避免在服务实例内存中存储用户会话信息（依赖 JWT），这样可以通过简单地增加服务实例数量来进行水平扩展。
- **数据库扩展:**
  - **垂直扩展:** 升级数据库服务器的 CPU、内存、存储规格。
  - **水平扩展 (读):** 配置 PostgreSQL 只读副本，将读密集型查询（如获取记录列表）路由到副本，分担主库压力。
  - **连接池:** 使用 ORM（TypeORM/Prisma）内置或配置的数据库连接池，有效管理数据库连接，避免连接耗尽。
  - **(未来) 分片:** 对于极大规模的数据，可能需要考虑数据库分片策略，但这会显著增加复杂性。
- **异步处理:** 充分利用 Node.js 的事件驱动、非阻塞 I/O 模型以及 NestJS 对`async/await`的良好支持，提高应用处理并发请求的能力。
- **缓存:** 对于频繁读取且不常变化的数据（如用户配置、儿童档案、可能还有一些常用的 AI 提示模板或知识片段），引入 Redis 等分布式缓存。使用 NestJS 的`CacheModule`可以方便地集成和管理缓存逻辑（如 Cache-Aside 模式）。
- **任务队列:** 将非核心、耗时的操作（如发送批量通知、生成复杂分析报告、数据导出）移至后台任务队列（如 BullMQ）处理，由独立的 Worker 进程执行，减轻 API 服务的直接压力，提高 API 响应速度。
- **负载均衡:** 在多个 NestJS 服务实例前部署负载均衡器（如 Nginx, HAProxy, 或云提供商的 LB 服务），将流量分发到各个实例，实现水平扩展和高可用。

#### 9.3. 可观测性 (Observability)

- **日志 (Logging):**
  - **结构化日志:** 使用 JSON 格式记录日志，包含标准字段（时间戳、日志级别、服务名、Trace ID、用户 ID 等）以及具体的请求/事件信息。推荐使用`pino`或`winston`库，并与 NestJS 的`Logger`集成。
  - **日志级别:** 合理使用 DEBUG, INFO, WARNING, ERROR, CRITICAL。生产环境通常配置为 INFO 或 WARNING 级别。
  - **内容:** 记录 API 请求入口和出口（含耗时）、关键业务流程节点、数据库查询（脱敏）、外部 API 调用（脱敏）、错误堆栈跟踪、AI 交互的详细步骤和结果。
  - **集中化:** 将所有服务实例的日志流式传输到集中的日志管理平台（如 ELK Stack - Elasticsearch, Logstash, Kibana；或 Grafana Loki, Datadog Logs, AWS CloudWatch Logs），以便于聚合、搜索和分析。

#### 9.4. 测试策略 (Testing)

- **单元测试 (Unit Tests):** 使用 **Jest** (NestJS 默认集成) 编写。专注于测试单个类（Service, Controller, Guard, Pipe 等）的内部逻辑。使用 Jest 的 Mocking 功能模拟外部依赖（如数据库 Repository、外部服务、`JwtService`等）。目标是覆盖核心业务逻辑，确保代码按预期工作。追求较高的代码覆盖率（例如 80%+）。
- **集成测试 (Integration Tests):** 使用 Jest 和`@nestjs/testing`的`Test.createTestingModule()`创建测试模块。测试多个单元（如 Controller 调用 Service，Service 调用 Repository）之间的交互。通常需要连接到**测试数据库**（独立的、每次测试前可重置状态的数据库实例），验证数据库操作、模块间数据流和依赖注入是否正确。
- **端到端测试 (End-to-End Tests / E2E Tests):** NestJS 默认使用 Jest 和**Supertest**库进行 E2E 测试。模拟真实的 HTTP 客户端向运行的应用实例发送请求，验证完整的 API 请求/响应流程，包括路由、认证、数据验证、业务逻辑处理和最终响应的状态码、结构及内容。覆盖核心用户场景。
- **持续集成 (CI):** 在代码仓库（如 GitHub, GitLab）中配置 CI 流水线（如 GitHub Actions, GitLab CI）。每当代码提交或合并请求时，自动触发流水线执行所有类型的测试（单元、集成、E2E）。确保代码变更不会破坏现有功能，保证代码质量。

## 10. 未来考虑与演进方向

- **AI 能力增强:**
  - 基于用户记录进行更深入的趋势分析和模式识别（例如，分析睡眠模式变化与喂养、活动的关系，并给出洞察）。
  - 实现更主动的、个性化的建议推送（例如，根据宝宝月龄和近期记录，主动提示可能的发育里程碑或注意事项）。
  - 引入更复杂的自然语言处理(NLP)技术来理解和处理用户的自由文本笔记或更复杂的过敏信息描述。
  - 探索支持多模态输入（例如，允许用户上传辅食图片进行记录和分析）。
  - 集成更专业的育儿知识库（RAG），提高 AI 回答的权威性和准确性。
- **功能扩展:**
  - 实现生长曲线的跟踪与可视化展示。
  - 增加疫苗接种计划与提醒功能。
  - 允许用户自定义记录项和追踪目标。
  - 提供数据导出功能，方便用户备份或自行分析。
  - 探索社区功能或引入认证专家问答模块。
  - 根据用户和儿童画像进行个性化的育儿内容（文章、视频、活动建议）推荐。
  - 与第三方智能硬件（如智能奶瓶、睡眠监测器、体温计）集成，自动获取数据。
  - 设计并实现用户成就/徽章系统，激励用户持续记录。
- **技术演进:**
  - 随着业务复杂度和团队规模的增长，适时将应用中稳定且独立的模块（例如 AI 服务、通知服务、分析服务）拆分为独立的微服务（利用 NestJS 的微服务支持）。
  - 在微服务架构下，引入事件驱动架构（EDA）使用消息队列（如 Kafka, RabbitMQ）处理服务间的异步通信和解耦。
  - 构建专门的数据仓库和数据分析平台，支持更复杂的数据分析和报表需求。
- **国际化 (i18n) / 本地化 (l10n):** 支持多语言界面和内容，以服务更广泛的用户群体（可使用`nestjs-i18n`等库）。
- **管理后台:** 开发一个 Web 管理界面，方便运营人员、客服或管理员管理用户账户、审核内容、配置系统参数、监控应用状态等。

---

## 项目必备知识

以下是快速上手本项目中 LangChain. Js + NestJS 开发的“必备知识清单”，帮助你迅速构建起核心能力。

1. 环境准备
   • 在 NestJS 项目根目录执行：
   Npm install langchain @langchain/openai @langchain/core @nestjs/config axios
   • 在 .env 中配置 OPENAI_API_KEY、可选 GOOGLE_API_KEY、MODEL_NAME、TEMPERATURE 等。
   • 确保已安装并启用了 @nestjs/config 模块加载环境变量。

2. 核心概念速览
   • BaseChatModel：LangChain 所有聊天模型的抽象接口，最常用的实现是 ChatOpenAI。
   • PromptTemplate：负责把系统提示、用户消息、上下文拼成最终 Prompt。
   • Runnable / 链（Chain）：通过 RunnableSequence、RunnableLambda、RunnableMap 等组件，将“上下文构造 →LLM 调用 → 安全检查”拆成可组合步骤。
   • LCEL（LangChain Expression Language）：提供“管道式”编排，链式 .pipe ()、. Invoke () 完成调用。

3. 在 NestJS 中集成 LangChain
   A) 定义全局 PROVIDER

```ts
// langchain.module.ts
@Global()
@Module({
  imports: [ConfigModule],
  providers: [
    {
      provide: 'LANGCHAIN_CHAT_MODEL',
      useFactory: (cfg: ConfigService) =>
        new ChatOpenAI({
          apiKey: cfg.get('OPENAI_API_KEY'),
          modelName: cfg.get('MODEL_NAME') || 'gpt-4o',
          temperature: +cfg.get('TEMPERATURE') || 0.7,
        }),
      inject: [ConfigService],
    },
  ],
  exports: ['LANGCHAIN_CHAT_MODEL'],
})
export class LangChainModule {}
```

B) 在 AppModule 中引入 LangChainModule。

4. 构建 Prompt
   • System 消息：定义 AI 角色、行为准则、安全规则。
   • Human 消息：用户提问。
   • 示例：

```ts
const system = SystemMessagePromptTemplate.fromTemplate(
  `你是专业育儿助手…严格禁止医疗建议…已知过敏原：{allergyInfo}`,
);
const human = HumanMessagePromptTemplate.fromTemplate('{userMessage}');
const chatPrompt = ChatPromptTemplate.fromMessages([system, human]);
```

5. 构建上下文生成 Runnable

```ts
const contextRunnable = new RunnableLambda({
  func: async ({childId, userId})=>{
    const child = await childrenService.findOneForUser(childId, userId);
    const records = await recordsService.findRecent(childId, 24);
    let ctx = `昵称:${child.nickname}\n年龄:${…}\n过敏:${child.allergy_info}\n…`;
    return { contextText: ctx, allergyInfo: child.allergy_info||'' };
  }
});
```

6. 构建安全检查 Runnable

```ts
const safetyRunnable = new RunnableLambda({
  func: async ({ llmResponse, allergyInfo }) => {
    let reply = llmResponse,
      flags = [];
    // 过敏词检测
    if (
      allergyInfo &&
      allergyInfo
        .split(/[,，\s]+/)
        .some((a) => new RegExp(`\\b${a}\\b`, `i`).test(reply))
    ) {
      reply = '检测到过敏原…请咨询专业人士。';
      flags.push('allergy_detected');
    }
    // 强制免责声明
    reply += '\n\n本回复仅供参考…';
    return { reply, safetyFlags: flags.join(';'), rawResponse: llmResponse };
  },
});
```

7. 组装 RunnableSequence 链

```ts
const chain = RunnableSequence.from([
  // 第一步：构建上下文
  RunnableMap.from({
    ctxData: input=> contextRunnable.invoke({childId:input.childId, userId:input.userId}),
    userMsg: new RunnablePassthrough().pipe(in=>in.userMessage),
  }),
  // 拼 Prompt 并调用模型
  RunnableMap.from({
    llmResponse: async input=>{
      const args = { context: input.ctxData.contextText, userMessage: input.userMsg };
      return chatPrompt.pipe(chatModel).pipe(new StringOutputParser()).invoke(args);
    },
    allergyInfo: in=>in.ctxData.allergyInfo
  }),
  // 安全检查
  input=> safetyRunnable.invoke({ llmResponse: input.llmResponse, allergyInfo: input.allergyInfo })
]);
```

8. 在 Service 中调用

```ts
@Injectable()
export class AIService {
  constructor(
    @Inject('LANGCHAIN_CHAT_MODEL') private chatModel: BaseChatModel,
    private readonly childrenService: ChildrenService,
    private readonly recordsService: RecordsService
  ){
    this.chain = /* 如上组装 */;
  }

  async getAiReply(userId:number, childId:number, userMessage:string){
    const result = await this.chain.invoke({ userId, childId, userMessage });
    // 保存 ChatHistory 并返回 result.reply、.rawResponse、.safetyFlags
    return result.reply;
  }
}
```

9. 测试与调优
   • 本地 Mock：在单元测试里用 Jest Mock chatModel. Invoke 返回假数据，验证上下文构建与安全检查逻辑。
   • 监控 Token 用量：prompt 和 response 长度；设置合理的温度、max_tokens。
   • 尝试 withRetry ()、timeout () 为 LLM 调用加超时和重试保护。

10. 后续进阶
    • 向量检索：引入向量数据库（如 Pinecone、RedisVector）做 RAG；
    • 会话管理：按 conversation_id 分组多轮对话；
    • Prompt 模板管理：针对不同场景维护多份模板；
    • 并行处理：对不依赖上下文的子任务可并行执行。

掌握以上 10 条，你就可以在本项目中有效地使用 LangChain. Js 快速搭建“构建上下文 → 组装 Prompt → 调用 LLM → 安全检查 → 返回结果”的核心流程。祝开发顺利！

---

## 项目架构

下面给出一份基于成熟 NestJS Boilerplate 的“AI 育儿助手”后端完整架构方案。您可以直接在此基础上 clone、安装依赖，完成大部分脚手架工作，然后专注业务开发。

---

一、选型及项目脚手架

1. 我们推荐使用 “Nx Monorepo + NestJS” 方案，结合社区成熟的 NestJS Boilerplate：
   • 官方 Nest CLI 脚手架：`nest new ai-parenting-backend`
   • 或者更完善的 Boilerplate：
   https://github.com/nestjs-boilerplate/nestjs-prisma-starter （基于 Prisma）
   https://github.com/jmcdo29/nestjs-realworld-example-app （基于 TypeORM）
2. 本示例以 **nestjs-prisma-starter** 为基础，结合 Prisma、Redis、BullMQ、LangChain. Js、Pino 等最佳实践。

---

二、整体目录结构（Monorepo/Nx 风格）

```
└─ ai-parenting-backend/
   ├─ apps/
   │   └─ api/                    # NestJS 应用入口
   │       ├─ src/
   │       │   ├─ main.ts
   │       │   ├─ app.module.ts
   │       │   ├─ app.controller.ts
   │       │   ├─ app.service.ts
   │       │   ├─ modules/
   │       │   │   ├─ auth/
   │       │   │   ├─ children/
   │       │   │   ├─ records/
   │       │   │   ├─ chat/
   │       │   │   ├─ ai/         # LangChain 集成
   │       │   │   ├─ notifications/
   │       │   │   └─ content/
   │       │   ├─ common/         # Filters / Guards / Interceptors / Decorators
   │       │   ├─ config/         # env 验证、模块注册
   │       │   ├─ database/       # PrismaModule、PrismaService
   │       │   ├─ queue/          # BullMQModule
   │       │   ├─ cache/          # CacheModule (Redis)
   │       │   ├─ logger/         # PinoLoggerModule
   │       │   └─ health/         # HealthChecks
   │       └─ test/
   ├─ libs/                       # 可选：封装共享代码
   │   ├─ dto/                    # 公共 DTO、Schema
   │   ├─ util/                   # 通用工具函数
   │   └─ types/                  # 公共类型定义
   ├─ prisma/                     # Prisma schema + migrations
   ├─ .env.example
   ├─ nest-cli.json
   ├─ nx.json
   ├─ workspace.json
   └─ package.json
```

---

三、核心模块说明

1. ConfigModule（全局）
   • 使用 `@nestjs/config` + Joi 验证 .env 中各项：DATABASE_URL、REDIS_URL、OPENAI_API_KEY、JWT_SECRET、BULL_PREFIX…
   • 配置所有微服务端口、限流、超时、Log Level。

2. DatabaseModule（全局）
   • 基于 Prisma，提供 `PrismaService` 注入。
   • `prisma/schema.prisma` 定义 users, children, records, chatHistory, allergen 等表；
   • 通过 `npx prisma migrate` 管理迁移。

3. AuthModule
   • JWT 签发/刷新；
   • `AuthGuard` + `RolesGuard`；
   • `PrismaUserRepository` + `UserService`；
   • 密码采用 Argon 2。

4. ChildrenModule & RecordsModule
   • CRUD Controller + Service；
   • DTO 校验：class-validator + class-transformer；
   • Records. Details 采用 JSON 字段，配合 Zod/Joi 在 DTO 层做 schema 验证。

5. ChatModule & AI Module
   A) **ChatModule** 负责接口暴露：

   - POST `/api/v1/chat` → 调用 `AIService.getAiReply(userId, childId, message)`
   - GET `/api/v1/children/:id/chats` → 历史记录
   - POST `/api/v1/chats/:id/feedback` → feedback
     B) **AIModule**（依赖 LangChainModule）：
   - 注入 `LANGCHAIN_CHAT_MODEL` (ChatOpenAI)；
   - `ContextBuilder`（PrismaService → 拉取 Child + Recent Records + 历史会话摘要）；
   - `PromptEngine`（多模板管理）；
   - `SafetyChecker`（结构化过敏原、医疗规则、免责声明）；
   - 组装 `RunnableSequence`，全链路可插拔 `.withRetry()`, `.timeout()`；
   - 持久化 ChatHistory。

6. Common Module
   • 全局 ExceptionFilter (统一错误响应)；
   • 全局 ValidationPipe (whitelist + transform)；
   • 全局 ThrottlerGuard；
   • LoggingInterceptor；
   • ResponseInterceptor (统一响应格式 `{success, data, error}`)。

7. QueueModule
   • BullMQ (任务队列)，用于异步通知、沉淀分析报表；
   • `NotificationsProducer`, `AnalyticsConsumer`。

8. CacheModule
   • RedisCache 用于存储儿童静态档案、Prompt 模板、Rate-limit；
   • 可选向量检索缓存。

9. LoggerModule
   • 基于 Pino，支持 JSON 结构化日志；
   • 集成 ☁️ Log 管理（ELK / Grafana Loki）；
   • 保留 traceId, spanId。

10. Health Module & Metrics
    • `@nestjs/terminus` 做 `/health`, `/metrics`；
    • PrometheusClient 用于关键指标（LLM latency, error_rate, token_usage）。

---

四、关键配置 (. Env. Example)

```
# 数据库
DATABASE_URL=postgresql://user:pass@host:5432/db?schema=public
# Redis (cache & queue)
REDIS_URL=redis://:pass@host:6379
# OpenAI
OPENAI_API_KEY=sk-...
MODEL_NAME=gpt-4o
TEMPERATURE=0.7
# JWT
JWT_SECRET=your_jwt_secret
JWT_EXPIRES_IN=1h
REFRESH_EXPIRES_IN=7d
# BullMQ
BULL_PREFIX=ai_parenting
# Nest
PORT=4000
NODE_ENV=development
# Throttler
THROTTLE_TTL=60
THROTTLE_LIMIT=20
```

---

五、启动与开发流程

1. 安装依赖
   `npm ci`

2. 生成 Prisma Client
   `npx prisma generate`

3. 运行数据库迁移
   `npx prisma migrate dev`

4. 启动本地服务
   `npm run start:dev` (热重载)

5. Swagger 文档
   自动在 `http://localhost:4000/api-docs` 生成。

6. 测试
   - 单元：`npm run test`
   - E 2 E：`npm run test:e2e`

---

六、后续扩展与运维

- 微服务演进：将 AIModule、NotificationModule、AnalyticsModule 独立部署；
- 部署：Docker + Kubernetes + Helm Charts；
- CI/CD：GitHub Actions 或 GitLab CI，包含 Lint、测试、构建、镜像发布；
- 安全：Secrets Manager、Vault，定期审计依赖漏洞；
- 监控告警：Prometheus + Alertmanager，AI 接口超时/错误率告警。

---

通过以上架构，您可以快速启动项目：

1. Clone Boilerplate
2. 按上述目录和模块组织代码、补充业务逻辑
3. 专注 AI 聊天上下文构建、Prompt 优化、安全检查

祝项目顺利落地！
